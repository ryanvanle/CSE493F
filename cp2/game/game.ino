#include <SPI.h>
#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>

#define SCREEN_WIDTH 128 // OLED display width, in pixels
#define SCREEN_HEIGHT 64 // OLED display height, in pixels

// Declaration for an SSD1306 display connected to I2C (SDA, SCL pins)
// The pins for I2C are defined by the Wire-library. 
// On an arduino UNO:       A4(SDA), A5(SCL)
// On an arduino MEGA 2560: 20(SDA), 21(SCL)
// On an arduino LEONARDO:   2(SDA),  3(SCL), ...
#define OLED_RESET     -1 // Reset pin # (or -1 if sharing Arduino reset pin)
#define SCREEN_ADDRESS 0x3D ///< See datasheet for Address; 0x3D for 128x64, 0x3C for 128x32
// Instantiate SSD1306 driver display object
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);

#define POT_PIN A0
#define LIGHT_PIN A1
#define SLIDER_PIN A2


// bitmaps

// 'right2', 62x34px
const unsigned char bongoCat_right2 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x80, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x01, 0x80, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x18, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x18, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0xe0, 0x1c, 0x00, 
	0x00, 0x00, 0x40, 0x00, 0x00, 0x18, 0x64, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x07, 0x84, 0x00, 
	0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 
	0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x08, 0x01, 0x80, 0x00, 0x00, 0x04, 0x00, 
	0x00, 0x10, 0x01, 0x90, 0x00, 0x00, 0x04, 0x00, 0xc0, 0x20, 0x00, 0x12, 0x00, 0x00, 0x04, 0x00, 
	0x38, 0x40, 0x00, 0x0e, 0x40, 0x1c, 0x08, 0x00, 0x07, 0x80, 0x00, 0x01, 0x80, 0x22, 0x08, 0x00, 
	0x01, 0x00, 0x00, 0x00, 0x06, 0x51, 0x10, 0x00, 0x02, 0x00, 0x00, 0x00, 0x06, 0x85, 0x08, 0x00, 
	0x02, 0x00, 0x38, 0x00, 0x00, 0xc0, 0x88, 0x00, 0x04, 0x00, 0x47, 0x80, 0x00, 0x98, 0x84, 0x00, 
	0x04, 0x01, 0x80, 0x78, 0x00, 0x98, 0x04, 0x00, 0x04, 0x02, 0x00, 0x07, 0x80, 0x80, 0x02, 0x00, 
	0x02, 0x0c, 0x00, 0x00, 0x78, 0x80, 0x02, 0x00, 0x01, 0xf0, 0x00, 0x00, 0x07, 0x80, 0x02, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x81, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x79, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1c, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'left2', 62x34px
const unsigned char bongoCat_left2 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x80, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x01, 0x80, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x18, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x18, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0xe0, 0x1c, 0x00, 
	0x00, 0x1c, 0x40, 0x00, 0x00, 0x18, 0x64, 0x00, 0x00, 0x22, 0x80, 0x00, 0x00, 0x07, 0x84, 0x00, 
	0x00, 0x51, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x85, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 
	0x00, 0xc0, 0x80, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x98, 0x81, 0x80, 0x00, 0x00, 0x04, 0x00, 
	0x00, 0x98, 0x01, 0x90, 0x00, 0x00, 0x04, 0x00, 0xc0, 0x80, 0x00, 0x12, 0x00, 0x00, 0x04, 0x00, 
	0x38, 0x80, 0x00, 0x0e, 0x40, 0x00, 0x08, 0x00, 0x07, 0x80, 0x00, 0x01, 0x80, 0x00, 0x08, 0x00, 
	0x00, 0xf8, 0x00, 0x00, 0x06, 0x00, 0x10, 0x00, 0x00, 0x07, 0x80, 0x00, 0x06, 0x00, 0x08, 0x00, 
	0x00, 0x00, 0x78, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x07, 0x80, 0x00, 0x00, 0x04, 0x00, 
	0x00, 0x00, 0x00, 0x78, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x07, 0x80, 0x00, 0x02, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x78, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x02, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x01, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x79, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x87, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x08, 0x03, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x08, 0x04, 0x00, 0x1c, 
	0x00, 0x00, 0x00, 0x00, 0x04, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xe0, 0x00, 0x00
};
// 'both2', 62x34px
const unsigned char bongoCat_both2 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x80, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x01, 0x80, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x18, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x18, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0xe0, 0x1c, 0x00, 
	0x00, 0x00, 0x40, 0x00, 0x00, 0x18, 0x64, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x07, 0x84, 0x00, 
	0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 
	0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x08, 0x01, 0x80, 0x00, 0x00, 0x04, 0x00, 
	0x00, 0x10, 0x01, 0x90, 0x00, 0x00, 0x04, 0x00, 0xc0, 0x20, 0x00, 0x12, 0x00, 0x00, 0x04, 0x00, 
	0x38, 0x40, 0x00, 0x0e, 0x40, 0x00, 0x08, 0x00, 0x07, 0x80, 0x00, 0x01, 0x80, 0x00, 0x08, 0x00, 
	0x01, 0x00, 0x00, 0x00, 0x06, 0x00, 0x10, 0x00, 0x02, 0x00, 0x00, 0x00, 0x06, 0x00, 0x08, 0x00, 
	0x02, 0x00, 0x38, 0x00, 0x00, 0x00, 0x08, 0x00, 0x04, 0x00, 0x47, 0x80, 0x00, 0x00, 0x04, 0x00, 
	0x04, 0x01, 0x80, 0x78, 0x00, 0x00, 0x04, 0x00, 0x04, 0x02, 0x00, 0x07, 0x80, 0x00, 0x02, 0x00, 
	0x02, 0x0c, 0x00, 0x00, 0x78, 0x00, 0x02, 0x00, 0x01, 0xf0, 0x00, 0x00, 0x06, 0x00, 0x02, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x01, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x79, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x87, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x08, 0x03, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x08, 0x04, 0x00, 0x1c, 
	0x00, 0x00, 0x00, 0x00, 0x04, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xe0, 0x00, 0x00
};
// 'neither2', 62x34px
const unsigned char bongoCat_neither2 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x80, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x01, 0x80, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x18, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x18, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0xe0, 0x1c, 0x00, 
	0x00, 0x1c, 0x40, 0x00, 0x00, 0x18, 0x64, 0x00, 0x00, 0x22, 0x80, 0x00, 0x00, 0x07, 0x84, 0x00, 
	0x00, 0x51, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x85, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 
	0x00, 0xc0, 0x80, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x98, 0x81, 0x80, 0x00, 0x00, 0x04, 0x00, 
	0x00, 0x98, 0x01, 0x90, 0x00, 0x00, 0x04, 0x00, 0xc0, 0x80, 0x00, 0x12, 0x00, 0x00, 0x04, 0x00, 
	0x38, 0x80, 0x00, 0x0e, 0x40, 0x1c, 0x08, 0x00, 0x07, 0x80, 0x00, 0x01, 0x80, 0x22, 0x08, 0x00, 
	0x00, 0xf8, 0x00, 0x00, 0x06, 0x51, 0x10, 0x00, 0x00, 0x07, 0x80, 0x00, 0x06, 0x85, 0x08, 0x00, 
	0x00, 0x00, 0x78, 0x00, 0x00, 0xc0, 0x88, 0x00, 0x00, 0x00, 0x07, 0x80, 0x00, 0x98, 0x84, 0x00, 
	0x00, 0x00, 0x00, 0x78, 0x00, 0x98, 0x04, 0x00, 0x00, 0x00, 0x00, 0x07, 0x80, 0x80, 0x02, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x78, 0x80, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x80, 0x02, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x81, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x79, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1c, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'both1', 62x34px
const unsigned char bongoCat_both1 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x40, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x02, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x18, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x18, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x01, 0x80, 0x00, 0x00, 
	0x00, 0x00, 0x03, 0x80, 0x00, 0x60, 0x00, 0x00, 0x00, 0xe0, 0x1c, 0x00, 0x00, 0x10, 0x00, 0x00, 
	0x00, 0x98, 0x60, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x87, 0x80, 0x00, 0x00, 0x04, 0x00, 0x00, 
	0x00, 0x80, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 
	0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80, 0x00, 0x00, 0x06, 0x00, 0x40, 0x00, 
	0x00, 0x80, 0x00, 0x00, 0x26, 0x00, 0x20, 0x00, 0x00, 0x80, 0x00, 0x01, 0x20, 0x00, 0x10, 0x0c, 
	0x00, 0x40, 0x00, 0x09, 0xc0, 0x00, 0x08, 0x70, 0x00, 0x40, 0x00, 0x06, 0x00, 0x00, 0x07, 0x80, 
	0x00, 0x20, 0x01, 0x80, 0x00, 0x00, 0x02, 0x00, 0x00, 0x40, 0x01, 0x80, 0x00, 0x00, 0x01, 0x00, 
	0x00, 0x40, 0x00, 0x00, 0x00, 0x70, 0x01, 0x00, 0x00, 0x80, 0x00, 0x00, 0x07, 0x88, 0x00, 0x80, 
	0x00, 0x80, 0x00, 0x00, 0x78, 0x06, 0x00, 0x80, 0x01, 0x00, 0x00, 0x07, 0x80, 0x01, 0x00, 0x80, 
	0x01, 0x00, 0x00, 0x78, 0x00, 0x00, 0xc1, 0x00, 0x01, 0x00, 0x01, 0x80, 0x00, 0x00, 0x3e, 0x00, 
	0x02, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 
	0x02, 0x78, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x03, 0x84, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 
	0x1c, 0x03, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x00, 0x80, 0x40, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x60, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'left1', 62x34px
const unsigned char bongoCat_left1 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x40, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x02, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x18, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x18, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x01, 0x80, 0x00, 0x00, 
	0x00, 0x00, 0x03, 0x80, 0x00, 0x60, 0x00, 0x00, 0x00, 0xe0, 0x1c, 0x00, 0x00, 0x10, 0x00, 0x00, 
	0x00, 0x98, 0x60, 0x00, 0x00, 0x08, 0xe0, 0x00, 0x00, 0x87, 0x80, 0x00, 0x00, 0x05, 0x10, 0x00, 
	0x00, 0x80, 0x00, 0x00, 0x00, 0x02, 0x28, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x02, 0x84, 0x00, 
	0x00, 0x80, 0x00, 0x00, 0x00, 0x04, 0x0c, 0x00, 0x00, 0x80, 0x00, 0x00, 0x06, 0x04, 0x64, 0x00, 
	0x00, 0x80, 0x00, 0x00, 0x26, 0x00, 0x64, 0x00, 0x00, 0x80, 0x00, 0x01, 0x20, 0x00, 0x04, 0x0c, 
	0x00, 0x40, 0x00, 0x09, 0xc0, 0x00, 0x04, 0x70, 0x00, 0x40, 0x00, 0x06, 0x00, 0x00, 0x07, 0x80, 
	0x00, 0x20, 0x01, 0x80, 0x00, 0x00, 0x7c, 0x00, 0x00, 0x40, 0x01, 0x80, 0x00, 0x07, 0x80, 0x00, 
	0x00, 0x40, 0x00, 0x00, 0x00, 0x78, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x07, 0x80, 0x00, 0x00, 
	0x00, 0x80, 0x00, 0x00, 0x78, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x07, 0x80, 0x00, 0x00, 0x00, 
	0x01, 0x00, 0x00, 0x78, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 
	0x02, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 
	0x02, 0x78, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x03, 0x84, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 
	0x1c, 0x03, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x00, 0x80, 0x40, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x60, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'neither1', 62x34px
const unsigned char bongoCat_neither1 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x40, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x02, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x18, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x18, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x01, 0x80, 0x00, 0x00, 
	0x00, 0x00, 0x03, 0x80, 0x00, 0x60, 0x00, 0x00, 0x00, 0xe0, 0x1c, 0x00, 0x00, 0x10, 0x00, 0x00, 
	0x00, 0x98, 0x60, 0x00, 0x00, 0x08, 0xe0, 0x00, 0x00, 0x87, 0x80, 0x00, 0x00, 0x05, 0x10, 0x00, 
	0x00, 0x80, 0x00, 0x00, 0x00, 0x02, 0x28, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x02, 0x84, 0x00, 
	0x00, 0x80, 0x00, 0x00, 0x00, 0x04, 0x0c, 0x00, 0x00, 0x80, 0x00, 0x00, 0x06, 0x04, 0x64, 0x00, 
	0x00, 0x80, 0x00, 0x00, 0x26, 0x00, 0x64, 0x00, 0x00, 0x80, 0x00, 0x01, 0x20, 0x00, 0x04, 0x0c, 
	0x00, 0x40, 0xe0, 0x09, 0xc0, 0x00, 0x04, 0x70, 0x00, 0x41, 0x10, 0x06, 0x00, 0x00, 0x07, 0x80, 
	0x00, 0x22, 0x29, 0x80, 0x00, 0x00, 0x7c, 0x00, 0x00, 0x42, 0x85, 0x80, 0x00, 0x07, 0x80, 0x00, 
	0x00, 0x44, 0x0c, 0x00, 0x00, 0x78, 0x00, 0x00, 0x00, 0x84, 0x64, 0x00, 0x07, 0x80, 0x00, 0x00, 
	0x00, 0x80, 0x64, 0x00, 0x78, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x07, 0x80, 0x00, 0x00, 0x00, 
	0x01, 0x00, 0x04, 0x78, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x07, 0x80, 0x00, 0x00, 0x00, 0x00, 
	0x02, 0x00, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x07, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x02, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'right1', 62x34px
const unsigned char bongoCat_right1 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x40, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x02, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x18, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x18, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x01, 0x80, 0x00, 0x00, 
	0x00, 0x00, 0x03, 0x80, 0x00, 0x60, 0x00, 0x00, 0x00, 0xe0, 0x1c, 0x00, 0x00, 0x10, 0x00, 0x00, 
	0x00, 0x98, 0x60, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x87, 0x80, 0x00, 0x00, 0x04, 0x00, 0x00, 
	0x00, 0x80, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 
	0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80, 0x00, 0x00, 0x06, 0x00, 0x40, 0x00, 
	0x00, 0x80, 0x00, 0x00, 0x26, 0x00, 0x20, 0x00, 0x00, 0x80, 0x00, 0x01, 0x20, 0x00, 0x10, 0x0c, 
	0x00, 0x40, 0xe0, 0x09, 0xc0, 0x00, 0x08, 0x70, 0x00, 0x41, 0x10, 0x06, 0x00, 0x00, 0x07, 0x80, 
	0x00, 0x22, 0x29, 0x80, 0x00, 0x00, 0x02, 0x00, 0x00, 0x42, 0x85, 0x80, 0x00, 0x00, 0x01, 0x00, 
	0x00, 0x44, 0x0c, 0x00, 0x00, 0x70, 0x01, 0x00, 0x00, 0x84, 0x64, 0x00, 0x07, 0x88, 0x00, 0x80, 
	0x00, 0x80, 0x64, 0x00, 0x78, 0x06, 0x00, 0x80, 0x01, 0x00, 0x04, 0x07, 0x80, 0x01, 0x00, 0x80, 
	0x01, 0x00, 0x04, 0x78, 0x00, 0x00, 0xc1, 0x00, 0x01, 0x00, 0x07, 0x80, 0x00, 0x00, 0x3e, 0x00, 
	0x02, 0x00, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x07, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x02, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// Array of all bitmaps for convenience. (Total bytes used to store images in PROGMEM = 2304)
const int bongoCat_allArray_LEN = 8;
const unsigned char* bongoCat_allArray[8] = {
	bongoCat_neither1,
  bongoCat_left1,
  bongoCat_right1,
  bongoCat_both1,
	bongoCat_neither2,
	bongoCat_left2,
	bongoCat_right2,
  bongoCat_both2
};

// 'isee', 47x40px
const unsigned char epd_bitmap_isee [] PROGMEM = {
	0x00, 0x00, 0x1f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x0e, 0x00, 0x00, 0x00, 0x03, 0x00, 0x01, 
	0x80, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x60, 0x00, 0x00, 0x18, 0x00, 0x00, 0x10, 0x00, 0x00, 0x20, 
	0x00, 0x00, 0x08, 0x00, 0x00, 0x40, 0x00, 0x00, 0x04, 0x00, 0x00, 0x83, 0xc0, 0x0f, 0x02, 0x00, 
	0x01, 0x1c, 0x00, 0x00, 0xe1, 0x00, 0x01, 0x20, 0x00, 0x00, 0x11, 0x00, 0x02, 0xc0, 0x00, 0x00, 
	0x0c, 0x80, 0x07, 0x80, 0x00, 0x00, 0x02, 0x40, 0x04, 0x00, 0x00, 0x00, 0x00, 0x40, 0x04, 0x00, 
	0x00, 0x00, 0x00, 0x40, 0x08, 0x00, 0x00, 0x00, 0x00, 0x20, 0x08, 0x00, 0x00, 0x00, 0x00, 0x20, 
	0x02, 0x38, 0x80, 0x04, 0x78, 0x80, 0x0f, 0xc7, 0xe0, 0x0f, 0x87, 0xc0, 0x1f, 0x83, 0xf0, 0x1f, 
	0x03, 0xe0, 0x3f, 0x01, 0xf8, 0x3f, 0x03, 0xf0, 0x3f, 0x01, 0xf8, 0x7f, 0x03, 0xf8, 0x7f, 0x01, 
	0xfc, 0x7f, 0x03, 0xfc, 0x7f, 0x83, 0xfc, 0x7f, 0x03, 0xf8, 0x3f, 0xc7, 0xf8, 0x3f, 0xc7, 0xf0, 
	0x1f, 0xff, 0xf0, 0x1f, 0xff, 0xf0, 0x0f, 0xff, 0xe0, 0x0f, 0xff, 0xe0, 0x07, 0xff, 0xc0, 0x07, 
	0xff, 0xc0, 0x05, 0xff, 0x00, 0x03, 0xff, 0x40, 0x04, 0x38, 0x00, 0x00, 0x78, 0x40, 0x02, 0x00, 
	0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 
	0x00, 0x80, 0x00, 0x00, 0x02, 0x00, 0x00, 0x40, 0x00, 0x00, 0x04, 0x00, 0x00, 0x20, 0x7f, 0xfc, 
	0x08, 0x00, 0x00, 0x10, 0x00, 0x00, 0x30, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x60, 0x00, 0x00, 0x03, 
	0x00, 0x01, 0x80, 0x00, 0x00, 0x00, 0xe0, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xf0, 0x00, 0x00
};
// 'inosee', 42x42px
const unsigned char epd_bitmap_inosee [] PROGMEM = {
	0x00, 0x00, 0xff, 0x80, 0x00, 0x00, 0x00, 0x07, 0x80, 0x38, 0x00, 0x00, 0x00, 0x18, 0x00, 0x06, 
	0x00, 0x00, 0x00, 0x60, 0x00, 0x01, 0x80, 0x00, 0x00, 0xc0, 0x00, 0x00, 0xc0, 0x00, 0x01, 0x00, 
	0x00, 0x00, 0x20, 0x00, 0x02, 0x00, 0x00, 0x00, 0x10, 0x00, 0x04, 0x00, 0x00, 0x00, 0x08, 0x00, 
	0x08, 0x00, 0x00, 0x00, 0x04, 0x00, 0x18, 0x00, 0x00, 0x00, 0x06, 0x00, 0x10, 0x00, 0x00, 0x00, 
	0x02, 0x00, 0x20, 0x00, 0x00, 0x00, 0x01, 0x00, 0x20, 0x00, 0x00, 0x00, 0x01, 0x00, 0x40, 0x00, 
	0x00, 0x00, 0x00, 0x80, 0x40, 0x00, 0x00, 0x00, 0x00, 0x80, 0x40, 0x00, 0x00, 0x00, 0x00, 0x80, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x90, 0x00, 0x21, 0x00, 0x02, 0x40, 0x98, 0x00, 0x40, 0x80, 
	0x04, 0x40, 0x88, 0x00, 0xc0, 0xc0, 0x04, 0x40, 0x84, 0x01, 0x80, 0x60, 0x08, 0x40, 0x83, 0x8e, 
	0x00, 0x1c, 0x70, 0x40, 0x80, 0x00, 0x00, 0x00, 0x00, 0x40, 0x80, 0x00, 0x00, 0x00, 0x00, 0x40, 
	0x80, 0x00, 0x00, 0x00, 0x00, 0x40, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 
	0x00, 0x80, 0x40, 0x00, 0x00, 0x00, 0x00, 0x80, 0x40, 0x00, 0x00, 0x00, 0x00, 0x80, 0x20, 0x00, 
	0x00, 0x00, 0x01, 0x00, 0x20, 0x00, 0x00, 0x00, 0x01, 0x00, 0x10, 0x00, 0x00, 0x00, 0x02, 0x00, 
	0x18, 0x00, 0x00, 0x00, 0x06, 0x00, 0x08, 0x00, 0x00, 0x00, 0x04, 0x00, 0x04, 0x00, 0x00, 0x00, 
	0x08, 0x00, 0x02, 0x03, 0xff, 0xf0, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0xc0, 
	0x00, 0x00, 0xc0, 0x00, 0x00, 0x60, 0x00, 0x01, 0x80, 0x00, 0x00, 0x18, 0x00, 0x06, 0x00, 0x00, 
	0x00, 0x07, 0x00, 0x78, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xc0, 0x00, 0x00
};

// Array of all bitmaps for convenience. (Total bytes used to store images in PROGMEM = 528)
const int epd_bitmap_allArray_LEN = 2;
const unsigned char* epd_bitmap_allArray[2] = {
	epd_bitmap_inosee,
	epd_bitmap_isee
};

// 'inoseeBig', 50x50px
const unsigned char epd_bitmap_inoseeBig [] PROGMEM = {
	0x00, 0x00, 0x0f, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x03, 0xc0, 0x00, 0x00, 0x00, 0x03, 
	0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 
	0x02, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0xc0, 
	0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x06, 
	0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x08, 0x00, 0x00, 
	0x00, 0x00, 0x04, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 
	0x02, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 
	0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x40, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x80, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x90, 0x00, 0x02, 0x10, 
	0x00, 0x00, 0x40, 0x88, 0x00, 0x04, 0x08, 0x00, 0x04, 0x40, 0x84, 0x00, 0x08, 0x04, 0x00, 0x08, 
	0x40, 0x86, 0x00, 0x18, 0x06, 0x00, 0x08, 0x40, 0x83, 0x00, 0x30, 0x03, 0x00, 0x10, 0x40, 0x81, 
	0xc0, 0xc0, 0x00, 0xe0, 0xc0, 0x40, 0x80, 0x3e, 0x00, 0x00, 0x3f, 0x00, 0x40, 0x80, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x40, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x80, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x40, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
	0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x80, 0x20, 0x00, 
	0x00, 0x00, 0x00, 0x01, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x10, 0x00, 0x00, 0x00, 
	0x00, 0x02, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x04, 
	0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x02, 
	0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x01, 0x00, 0x7f, 0xff, 0x80, 0x20, 0x00, 0x00, 0xc0, 0x00, 
	0x00, 0x00, 0xc0, 0x00, 0x00, 0x60, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x10, 0x00, 0x00, 0x02, 
	0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x03, 0x80, 0x00, 0x30, 0x00, 0x00, 
	0x00, 0x00, 0xf0, 0x03, 0x80, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xfc, 0x00, 0x00, 0x00
};
// 'iseeBig', 59x51px
const unsigned char epd_bitmap_iseeBig [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xe0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x07, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x03, 0x80, 0x00, 0x00, 
	0x00, 0x00, 0xc0, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x30, 0x00, 0x00, 
	0x00, 0x02, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 
	0x00, 0x18, 0x0e, 0x00, 0x1c, 0x02, 0x00, 0x00, 0x00, 0x10, 0xf0, 0x00, 0x03, 0xc1, 0x00, 0x00, 
	0x00, 0x23, 0x00, 0x00, 0x00, 0x30, 0x80, 0x00, 0x00, 0x4c, 0x00, 0x00, 0x00, 0x08, 0x40, 0x00, 
	0x00, 0x98, 0x00, 0x00, 0x00, 0x06, 0x20, 0x00, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x01, 0x20, 0x00, 
	0x01, 0x40, 0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 
	0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 
	0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 
	0x01, 0x1f, 0xcc, 0x00, 0x0c, 0xff, 0x30, 0x00, 0x03, 0xf0, 0xfe, 0x00, 0x1f, 0xc3, 0xf8, 0x00, 
	0x07, 0xe0, 0x3f, 0x80, 0x3f, 0x81, 0xfc, 0x00, 0x0f, 0xe0, 0x3f, 0x80, 0x7f, 0x00, 0xfe, 0x00, 
	0x1f, 0xc0, 0x3f, 0xc0, 0xff, 0x00, 0xff, 0x00, 0x3f, 0xc0, 0x3f, 0xe1, 0xff, 0x00, 0xff, 0x80, 
	0x7f, 0xe0, 0x3f, 0xf1, 0xff, 0x00, 0xff, 0x80, 0x3f, 0xe0, 0x3f, 0xe1, 0xff, 0x81, 0xff, 0x80, 
	0x3f, 0xf0, 0x7f, 0xe0, 0xff, 0x81, 0xff, 0x00, 0x1f, 0xff, 0xff, 0xc0, 0x7f, 0xff, 0xfe, 0x00, 
	0x0f, 0xff, 0xff, 0x80, 0x7f, 0xff, 0xfe, 0x00, 0x07, 0xff, 0xff, 0x00, 0x3f, 0xff, 0xfc, 0x00, 
	0x07, 0xff, 0xfe, 0x00, 0x0f, 0xff, 0xfc, 0x00, 0x02, 0xff, 0xfc, 0x00, 0x07, 0xff, 0xe8, 0x00, 
	0x02, 0x7f, 0xf0, 0x00, 0x01, 0xff, 0x88, 0x00, 0x02, 0x06, 0x00, 0x00, 0x00, 0x18, 0x08, 0x00, 
	0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 
	0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 
	0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 
	0x00, 0x10, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 
	0x00, 0x04, 0x07, 0xff, 0xfc, 0x04, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 
	0x00, 0x01, 0x80, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0xc0, 0x00, 0x00, 
	0x00, 0x00, 0x18, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x3c, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x7f, 0xc0, 0x00, 0x00, 0x00
};

// Array of all bitmaps for convenience. (Total bytes used to store images in PROGMEM = 800)
const int epd_bitmap_allArrayBig_LEN = 2;
const unsigned char* epd_bitmap_allArrayEyes[2] = {
	epd_bitmap_inoseeBig,
	epd_bitmap_iseeBig
};


// AI GENERATED WORDS
const String positiveWords[] =  {
  "Great!",
  "Bravo!",
  "Well done!",
  "Excellent!",
  "Kudos!",
  "Awesome!",
  "Superb!",
  "Terrific!",
};

// AI GENERATED WORDS
const String niceTryWords[]  = {
  "Nice Try!",
  "Almost!",
  "Next Time!",
  "Close!",
  "So Close!",
  "Not Quite!",
  "Good Try!",
};

int bongoTones[] = {0, 220, 261, 523};

// buttons
int RIGHT_BUTTON_PIN = 5;
int LEFT_BUTTON_PIN = 6;
int buttonPins[] = {LEFT_BUTTON_PIN, RIGHT_BUTTON_PIN}; 
int buttonAmount = *(&buttonPins + 1) - buttonPins;

int buttonStatesValues[] = {LOW, LOW};
int previousRawButtonValues[] = {LOW, LOW};
int debouncedButtonValues[] = {LOW, LOW};
unsigned long buttonStateChangeTimestamps[] = {0, 0};
const int DEBOUNCE_WINDOW = 0; // in milliseconds

// buzzer
int OUTPUT_PIEZO_PIN = 13;

// menu
enum menuButton {
  play,
  score,
  length,
};

menuButton currentState = play;
boolean hasNotMenuMoverPressedRecently = true;

// game state

int currentScore = 0;
int currentLives = 3;
int currentGame = -1;

int INTRO_TIME_DELAY = 1000;
int GAME_AMOUNT = 3;
int i = 0;
boolean hasShownIntro = false;

// timer
unsigned long startTime = 0;
unsigned long duration = 0;
boolean isTimerRunning = false;

void setup(){
  randomSeed(analogRead(A5));
  Serial.begin(9600);
  delay(2000);

  // Serial.println("running");

  Serial.println("running " + String(random(1, 10000)));

  // Initialize the display. If it fails, print failure to Serial
  // and enter an infinite loop
  if (!display.begin(SSD1306_SWITCHCAPVCC, 0x3D)) { // Address 0x3D for 128x64
    Serial.println(F("FAILED"));
    Serial.println(F("SSD1306 allocation failed"));
    Serial.println(F("FAILED"));

    for (;;); // Don't proceed, loop forever
  }


  pinMode(LEFT_BUTTON_PIN, INPUT);
  pinMode(RIGHT_BUTTON_PIN, INPUT);
  pinMode(OUTPUT_PIEZO_PIN, OUTPUT);


  display.clearDisplay();
}

boolean DEBUG_FLAG = false;

boolean GAME_DEBUG_FLAG = true;
int DEBUG_GAME_NUMBER = 4; 


void runGame() {
  updateButtonStates();
  switch (currentGame) {
    case -2:
        displayEndgame();
        break;
    case 1:
        displayMatch();
        break;
    case 2:
        displayMash();
        break;
    case 3:
        displayCover();
        break;
    case 4:
        displayTune();
        break;
    case 5:
        displayOpen();
        break;
    case 6:
        displayDodge();
        break;
    case 7:
        displayTilt();
        break;
    default:
        displayMenu();
        break;
  }
}


void testStuff() {
  // displayInputsDEBUG();


  // display.clearDisplay();
  // displayTest();
  // display.display();

  
  // playTimerTransition(0, 0);
  // displayRoundEnd(false);
  // delay(1000);

  // if (!isTimerRunning) {
  //   setAndStartTimer(8);
  // }
  
  // display.clearDisplay();
  // displayText(String(remainingTimerTimeSeconds()), 1, 20, 20);
  // displayUI();
  // display.display();


  // if (checkTimerElasped()) {
  //   clearTimer();
  // }
  // if (!isTimerRunning) {
  //   setAndStartTimer(5); 
  //   displayTextCenter("set timer", 1, 0 , 0);
  //   display.display();
  //   return;
  // }


  // if (checkTimerElasped()) {
  //   displayTextCenter("Timer done", 2, 0, 0);
  //   clearTimer();
  //   delay(1000);
  // } else {
  //   displayTextCenter(String(remainingTimerTimeMS()), 2, 0, -10);
  //   displayTextCenter(String(remainingTimerTimeSeconds()), 2, 0, 10);
  // }

  // display.display();

}

void loop(){
  display.invertDisplay(false);

  if (DEBUG_FLAG) {
    testStuff();
    return;
  }

  runGame();
}

int getButtonValue(int PIN_NUMBER) {
  
  for (int i = 0; i < buttonAmount; i++) {
    if (buttonPins[i] == PIN_NUMBER) return debouncedButtonValues[i];
  }

  return -1;

}

void displayInputsDEBUG() {
  updateButtonStates();


  display.clearDisplay();

  int potValue = analogRead(POT_PIN);
  int sliderValue = analogRead(SLIDER_PIN);
  int lightValue = analogRead(LIGHT_PIN);


  displayText("pot value: " + String(potValue), 1, 5, 15);
  displayText("slider value: " + String(sliderValue), 1, 5, 30);
  displayText("light value: " + String(lightValue), 1, 5, 45);



  display.display();

}


void displayMenu() {
  display.clearDisplay();
  
  if (getButtonValue(LEFT_BUTTON_PIN) == HIGH && currentState == play) {
    currentGame = getRandomGame();
    return;
  }

  String gameTitle = "VERBS";
  displayTextCenter(gameTitle, 3, 0, -16);
  displayMenuButtons();
  display.display();
}

void displayTest() {
  if (!hasShownIntro) displayIntro("test");
  display.clearDisplay();
  displayTextCenter("test2", 3, 0, 0);
  display.display();
}

/*

template game

void displayGAMENAME() {
  if (!hasShownIntro) {
    clearTimer();
  
    displayIntro("GAME NAME");

    // intro put here


    setAndStartTimer(10);
    return;
  }

  display.clearDisplay();
  displayUI();

  // game logic here



  display.display();


  if (checkTimerElasped()) {
    displayRoundEnd(false);
    switchGame(false);
  }
  
}


*/

String dMajorNotes[] = {"D5", "D5 Sharp", "E5", "F5", "F5 Sharp", "G5", "G5 Sharp", "A5", "A5 Sharp", "B5", "C6", "C6 Sharp", "D6"}; //D5 to D6
long dMajorFrequency[] = {587,622,659,698,740,784,831,880,932,988,1047,1109,1175};

const long dMajorArrayLength = 13;
const long lowestPotValue = 570;
const long highestPotValue = 4095;

String targetNote = "targetValue";

long firstTimeSeen = 0;
boolean previouslyTheSame;

void displayTune() {
  if (!hasShownIntro) {
    clearTimer();  
    displayIntro("TUNE");

    // intro put here
    display.clearDisplay();

  
    int potValue = analogRead(POT_PIN);
    long currentFrequency = map(potValue, lowestPotValue, highestPotValue, dMajorFrequency[0] - 100, dMajorFrequency[12] + 100);
    String currentNote = getCurrentNote(currentFrequency);

    int targetIndex = random(0, 13);
    targetNote = dMajorNotes[targetIndex];

    previouslyTheSame = false;

    if (targetNote.equals(currentNote)) {
      targetIndex = random(0, 13);
      targetNote = dMajorNotes[targetIndex];
    }

    // int targetFrequencyIndex = getNoteIndex(targetNote);

    // tone(OUTPUT_PIEZO_PIN, dMajorFrequency[targetIndex]);

    displayTextCenter("Target", 1, 0, -5);
    displayTextCenter(targetNote, 1, 0, 5);

    display.display();
    delay(1000);
    setAndStartTimer(10);
    return;
  }

  display.clearDisplay();
  displayUI();

  // game logic here
  
  int potValue = analogRead(POT_PIN);
  long currentFrequency = map(potValue, lowestPotValue, highestPotValue, dMajorFrequency[0] - 100, dMajorFrequency[12] + 100);
  String currentNote = getCurrentNote(currentFrequency);

  tone(OUTPUT_PIEZO_PIN, currentFrequency);




  boolean isSameNote = currentNote.equals(targetNote);

  if (isSameNote && !previouslyTheSame) {
    previouslyTheSame = true;
    firstTimeSeen = remainingTimerTimeMS();
  } else if (isSameNote && previouslyTheSame) {

    boolean hasEnoughTimePassed = firstTimeSeen - remainingTimerTimeMS() > 1000;

    if (hasEnoughTimePassed) {
      displayRoundEnd(true);
      switchGame(true);
    }



  } else {
    firstTimeSeen = 0;
    previouslyTheSame = false;
  }





  displayTextCenter("Current", 1, -30, -10);
  displayTextCenter(currentNote, 1, -30, 5);

  displayTextCenter("Target", 1, 30, -10);
  displayTextCenter(targetNote, 1, 30, 5);




  display.display();


  if (checkTimerElasped()) {
    noTone(OUTPUT_PIEZO_PIN);
    displayRoundEnd(false);
    switchGame(false);
  }
  
}

int getNoteIndex(String noteName) {

  for (int i = 0; i < 13; i++) {
    if (noteName.equals(dMajorNotes[i])) return i;
  }

  return 0;
}

String getTargetRandomNote() {
  int index = random(0, 13);
  return dMajorNotes[i];
}

String getCurrentNote(long comparedFrequency) {

  long closest = dMajorFrequency[0];
  long minDiff = absoluteValue(comparedFrequency - dMajorFrequency[0]); 
  String closestString = dMajorNotes[0];
      
  for (int i = 1; i < 13; i++) {
    long diff = absoluteValue(comparedFrequency - dMajorFrequency[i]); 
    if (diff < minDiff) {
        minDiff = diff;
        closest = dMajorFrequency[i];
        closestString = dMajorNotes[i];
    }
  }

  return closestString;

}


long absoluteValue(long number) {

  return number >= 0 ? number : number * -1;

}




void displayOpen() {
  if (!hasShownIntro) {
    clearTimer();
  
    displayIntro("GAME NAME");

    // intro put here


    setAndStartTimer(10);
    return;
  }

  display.clearDisplay();
  displayUI();

  // game logic here



  display.display();


  if (checkTimerElasped()) {
    displayRoundEnd(false);
    switchGame(false);
  }
  
}


void displayDodge() {
  if (!hasShownIntro) {
    clearTimer();
  
    displayIntro("GAME NAME");

    // intro put here


    setAndStartTimer(10);
    return;
  }

  display.clearDisplay();
  displayUI();

  // game logic here



  display.display();


  if (checkTimerElasped()) {
    displayRoundEnd(false);
    switchGame(false);
  }
  
}



void displayTilt() {
  if (!hasShownIntro) {
    clearTimer();
  
    displayIntro("GAME NAME");

    // intro put here


    setAndStartTimer(10);
    return;
  }

  display.clearDisplay();
  displayUI();

  // game logic here



  display.display();


  if (checkTimerElasped()) {
    displayRoundEnd(false);
    switchGame(false);
  }
  
}






boolean hasCovered = false;

void displayCover() {
  if (!hasShownIntro) {
    clearTimer();

    hasCovered = false;

    displayIntro("COVER!");
    setAndStartTimer(5);
    return;
  }

  display.clearDisplay();
  displayUI();


  int darknessLevel = analogRead(LIGHT_PIN);
  const int DARKNESS_LEVEL_THRESHOLD = 4000;

  Serial.println(darknessLevel);

  boolean isCurrentlyCovered = darknessLevel >= DARKNESS_LEVEL_THRESHOLD;


  if (isCurrentlyCovered) {
    hasCovered = true;
    display.drawBitmap(39, 6, epd_bitmap_inoseeBig, 50, 50, WHITE); //42x42
    // clearTimer();
  } else if (hasCovered && !isCurrentlyCovered) {
    display.drawBitmap(39, 6, epd_bitmap_inoseeBig, 50, 50, WHITE); //42x42
    delay(1000);
    displayRoundEnd(true);
    switchGame(true);
  } else {
    display.drawBitmap(35, 6, epd_bitmap_iseeBig, 59, 51, WHITE); //42x42
 
  }



  // if (remainingTimerTimeSeconds() < 3) {
  //   display.drawBitmap(39, 6, epd_bitmap_inoseeBig, 50, 50, WHITE); //42x42
  // } else {
  //   display.drawBitmap(35, 6, epd_bitmap_iseeBig, 59, 51, WHITE); //42x42
  // }

  // // displayEyes();



  display.display();


 if (checkTimerElasped() && isTimerRunning) {
    displayRoundEnd(false);
    switchGame(false);
  }

  
}



int previousBongoIndex = 0;
int currentMatchIndex = 0;
int matchSequence = 10;
int matchArrayLength = 20;
int matchArray[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};

void displayMatch() {
  if (!hasShownIntro) {
    clearTimer();
    setTimer(10);

    generateSequence();
    displayIntro("MATCH");
    
    display.clearDisplay();
    displayUI();
    display.drawBitmap(3, 15, bongoCat_neither1, 62, 34, WHITE);
    display.drawBitmap(64, 15, bongoCat_neither2, 62, 34, WHITE);
    display.display();
    
    delay(200);

    matchSequence = random(3, 6);
  
    playBongoCatSequence();
    previousBongoIndex = 0;
    currentMatchIndex = 0;
    startTimer();
  
    return;
  }

  display.clearDisplay();

  displayBongoCats();
  displayUI();
  
  int currentBongoIndex = getCurrentBongoInputIndex();

  boolean isPreviousNeutral = previousBongoIndex == 0;
  boolean isCurrentNotNeutral = currentBongoIndex != 0;
  boolean isDifferent = previousBongoIndex != currentBongoIndex;


  if ((isPreviousNeutral || isDifferent) && isCurrentNotNeutral) {
    
    boolean isCorrect = correctBongoInputChecker(currentBongoIndex);

    if (isCorrect) {
    
      currentMatchIndex++;
    
      if (currentMatchIndex == matchSequence) {

        displayRoundEnd(true);
        switchGame(true);

      }

    } else {

      displayRoundEnd(false);
      switchGame(false);

      // incorrect! switch games
    }
  }

  display.display();

  if (checkTimerElasped()) {
    displayRoundEnd(false);
    switchGame(false);
  }


  previousBongoIndex = currentBongoIndex;
}

int mashAmount;
int mashInitial;
void displayMash() {

  if (!hasShownIntro) {
    updateButtonStates();
    displayIntro("MASH");
    mashAmount = 0;
    mashInitial = random(50, 81);
    previousBongoIndex = 0;
    currentMatchIndex = 0;
    

    clearTimer();
    setAndStartTimer(15);
    return;
  }



  updateButtonStates();
  
  display.clearDisplay();
  displayUI();

  int currentBongoIndex = getCurrentBongoInputIndex();
  playBongoTone(currentBongoIndex);
  display.drawBitmap(32, 5, bongoCat_allArray[currentBongoIndex + 4], 62, 34, WHITE);

  boolean isCurrentNotSame = previousBongoIndex != currentBongoIndex;
  boolean isCurrentNotNeutral = currentBongoIndex != 0;

  if (isCurrentNotSame && isCurrentNotNeutral) {
    mashAmount++;
  }

  displayTextCenter(String(mashInitial - mashAmount), 1, 0, 20);
  display.display();

  if (mashInitial - mashAmount == 0) {
    displayRoundEnd(true);
    switchGame(true);
  }

  if (checkTimerElasped()) {
    displayRoundEnd(false);
    switchGame(false);
  }

  previousBongoIndex = currentBongoIndex;
}

boolean correctBongoInputChecker(int inputIndex) {
  return matchArray[currentMatchIndex] == inputIndex;
}

void switchGame(boolean didWin) {
  currentGame = getRandomGame();
  hasShownIntro = false;


  if (didWin) {
    currentScore++;
  } else if (!GAME_DEBUG_FLAG) {
    currentLives--;
  }

  boolean isDivisable = currentScore % 5 == 0;
  boolean hasMaxHearts = currentLives > 5;
  boolean canGetExtraLife = isDivisable && hasMaxHearts;
  
  if (canGetExtraLife) currentLives++;
  if (currentLives <= 0) startEndgame();
}

void startEndgame() {
  currentGame = -2;
}

void displayEndgame() {
  display.clearDisplay();
  displayTextCenter("GAME OVER!", 2, 0, -5);
  displayTextCenter("final score: " + String(currentScore), 1, 0, 10);
  display.display();
}


void generateSequence() {
  for (int i = 0; i < matchSequence; i++) {
    matchArray[i] = random(1, 4);
  }

}

void playBongoCatSequence() {
  for (int i = 0; i < matchSequence; i++) {
    display.clearDisplay();
    displayUI();
    display.drawBitmap(3, 15, bongoCat_neither1, 62, 34, WHITE);
    display.drawBitmap(64, 15, bongoCat_neither2, 62, 34, WHITE);
    display.display();
    
    delay(50);

    display.clearDisplay();
    display.drawBitmap(3, 15, bongoCat_neither1, 62, 34, WHITE);
    displayUI();


    switch (matchArray[i]) {
      case 1:
        tone(OUTPUT_PIEZO_PIN, 220);
        display.drawBitmap(64, 15, bongoCat_left2, 62, 34, WHITE);
        break;
      case 2:
        tone(OUTPUT_PIEZO_PIN, 261);
        display.drawBitmap(64, 15, bongoCat_right2, 62, 34, WHITE);
        break;
      case 3:
        tone(OUTPUT_PIEZO_PIN, 523);
        display.drawBitmap(64, 15, bongoCat_both2, 62, 34, WHITE);
        break;
      default:
        noTone(OUTPUT_PIEZO_PIN);
        display.drawBitmap(64, 15, bongoCat_neither2, 62, 34, WHITE);
        break;
    }

    display.display();
    delay(425);
    noTone(OUTPUT_PIEZO_PIN); // turn off the waveform

  }
}

int getCurrentBongoInputIndex() {
  
  boolean isLeft = getButtonValue(LEFT_BUTTON_PIN);
  boolean isRight = getButtonValue(RIGHT_BUTTON_PIN);

  if (isLeft && isRight) {
    return 3;
  } else if (isLeft) {
    return 1;
  } else if (isRight) {
    return 2;
  }

  return 0;
}

void displayBongoCats() {  
  int index = getCurrentBongoInputIndex();
  playBongoTone(index);
  display.drawBitmap(3, 15, bongoCat_allArray[index], 62, 34, WHITE);
  display.drawBitmap(64, 15, bongoCat_neither2, 62, 34, WHITE);
}

void playBongoTone(int index) {
  if (index == 0) {
    noTone(OUTPUT_PIEZO_PIN);
    return;
  } 

  tone(OUTPUT_PIEZO_PIN, bongoTones[index]);
}

void displayIntro(String verb) {
    display.clearDisplay();
    displayTextCenter(verb, 3, 0, -5);
    displayHearts();
    displayScore();

    display.display();
    hasShownIntro = true;
    delay(INTRO_TIME_DELAY);
    display.clearDisplay();
}

void displayInputIcon(boolean isIntro) {
  return;
}

void displayHearts() {
  display.setCursor(0, 1);
  display.setTextSize(1);

  int heartIndex = 3;

  for (int i = 0; i < currentLives; i++) {
    display.write(heartIndex);
  }
}

void displayScore() {
  int xOffset;

  if (currentScore < 10) {
    xOffset = 120;
  } else if (currentScore < 100) {
    xOffset = 115;
  } else if (currentScore < 1000) {
    xOffset = 110;
  } else {
    xOffset = 103;
  }

  displayText(String(currentScore), 1, xOffset, 10);
}

void displayTimer() {

    int radius = 3;
    int xPos = 3;
    int yPos = 59;
    long timeMS = remainingTimerTimeMS();

    int speed = 80;

    long longLineLength = map(timeMS, 3000, duration, 0, speed);
    long downLineLength = map(timeMS, 2000, duration, 0, speed);
    long shortLineLength = map(timeMS, 1000, duration, 0, speed);
    long upLineLength = map(timeMS, 0, duration, 0, speed );

    // Serial.print("long: ");
    // Serial.println(longLineLength);

    if (longLineLength > 0) {
      display.drawCircle(xPos, yPos, radius, WHITE); // circle
      display.drawFastVLine(xPos, yPos - radius - 2, 2, WHITE);
      display.drawFastHLine(xPos, yPos - radius - 2, 6, WHITE);
      display.drawFastVLine(xPos + 6, yPos - radius - 2, 2 + radius + radius, WHITE);

      display.drawFastHLine(xPos + 6, yPos + radius, longLineLength, WHITE);
      drawTimerTrailEffect(xPos + 6 + longLineLength, yPos + radius);

    } else if (downLineLength > 0) {
      display.drawCircle(xPos, yPos, radius, WHITE); // circle
      display.drawFastVLine(xPos, yPos - radius - 2, 2, WHITE);
      display.drawFastHLine(xPos, yPos - radius - 2, 6, WHITE);
      display.drawFastVLine(xPos + 6, yPos - radius - 2, downLineLength, WHITE);
      drawTimerTrailEffect(xPos + 6, yPos - radius - 2 + downLineLength);

    } else if (shortLineLength > 0) {
      display.drawCircle(xPos, yPos, radius, WHITE); // circle
      display.drawFastVLine(xPos, yPos - radius - 2, 2, WHITE);
      display.drawFastHLine(xPos, yPos - radius - 2, shortLineLength, WHITE);
      drawTimerTrailEffect(xPos + shortLineLength, yPos - radius - 2);

    } else if (upLineLength > 0) {
      display.drawCircle(xPos, yPos, radius, WHITE); // circle
      display.drawFastVLine(xPos, yPos - radius - upLineLength, upLineLength - 1, WHITE);
      drawTimerTrailEffect(xPos, yPos - radius - upLineLength - 1);

    } else {
      playTimerTransition(xPos, yPos);
    }
}

void drawTimerTrailEffect(int xPos, int yPos) {
  
  int triangleAmount = 2;
  int radius = 4;


  for (int i = 0; i < triangleAmount; i++) {
    int x0 = xPos + random(-radius, radius);
    int y0 = yPos + random(-radius, radius);

    int x1 = xPos + random(-radius, radius);
    int y1 = yPos + random(-radius, radius);
    
    int x2 = xPos + random(-radius, radius);
    int y2 = yPos + random(-radius, radius);

    display.drawTriangle(x0, y0, x1, y1, x2, y2, WHITE);    
  }


}


void playTimerTransition(int xPos, int yPos) {
  // from the adafruit examples 
  for(int16_t i = 0; i < display.width(); i += 2) {
    display.drawCircle(xPos, yPos, i, SSD1306_WHITE);
    display.display();
  }

  // delay(500);

}

void displayUI() {
  displayHearts();
  displayScore();
  displayInputIcon(false);
  displayTimer();
}

void displayRoundEnd(boolean didWin) {

  display.clearDisplay();
  String randomSaying = didWin ? getRandomPositiveWord() : getRandomNiceTryWord();
  
  if (currentGame == 3) randomSaying = didWin ? "I no see" : "I see";
  



  boolean isStringTooLong = randomSaying.length() > 12;
  int textSize = isStringTooLong ? 1 : 2;


  if (!didWin) display.invertDisplay(true);
  displayTextCenter(randomSaying, textSize, 0, 0); 
  display.display();
  delay(1000);
}

void playWinTone() {

}

void playLoseTone() {

}

void updateButtonStates() {
  
  for (int i = 0; i < buttonAmount; i++) {
    int rawButtonValue = digitalRead(buttonPins[i]);
    if(rawButtonValue != previousRawButtonValues[i]) buttonStateChangeTimestamps[i] = millis();
    
    unsigned long difference = millis() - buttonStateChangeTimestamps[i];

    if(difference >= DEBOUNCE_WINDOW) debouncedButtonValues[i] = rawButtonValue;
    previousRawButtonValues[i] = rawButtonValue;
  }
}

void displayMenuButtons() {

  String menuOptions[] = {"play", "score"};
  int menuButtonLength = *(&menuOptions + 1) - menuOptions;

  int xPositions[] = {3, 68};
  int yPositions[] = {60, 60};
  int textSize = 2;

  boolean isButtonPressed = getButtonValue(RIGHT_BUTTON_PIN) == HIGH;
  if (isButtonPressed && hasNotMenuMoverPressedRecently) {
    currentState = (menuButton) ((currentState + 1) % length);

    if (currentState == length) {
      currentState = play; 
    }

    // Serial.println()
    hasNotMenuMoverPressedRecently = false;
  } else if (!isButtonPressed) {
    hasNotMenuMoverPressedRecently = true;
  }


  for (int i = 0; i < menuButtonLength; i++) {
    displayText(menuOptions[i], textSize, xPositions[i], yPositions[i]);
    if ((menuButton) i == currentState) {
      drawUnderline(menuOptions[i], xPositions[i], yPositions[i]);
    }
  }

  // displayTextCenter("play", 2, -30, 15);

}

void drawUnderline(String text, int xPosition, int yPosition) {
  int16_t x;
  int16_t y;
  uint16_t textWidth;
  uint16_t textHeight;

  display.getTextBounds(text, 0, 0, &x, &y, &textWidth, &textHeight);

  int offset = 2;
  display.drawFastHLine(xPosition - 1, yPosition + offset, textWidth, WHITE);

}

void displayTextCenter(String text, uint8_t textSize, int16_t xOffset, int16_t yOffset) {
  int16_t x;
  int16_t y;
  uint16_t textWidth;
  uint16_t textHeight;

  display.setTextSize(textSize);
  display.setTextColor(WHITE, BLACK);
  display.getTextBounds(text, 0, 0, &x, &y, &textWidth, &textHeight);
  centerCursorWithText(xOffset, yOffset, textWidth, textHeight);
  display.print(text);
}

void displayText(String text, uint8_t textSize, int16_t xPosition, int16_t yPosition) {
  int16_t x;
  int16_t y;
  uint16_t textWidth;
  uint16_t textHeight;

  display.setTextSize(textSize);
  display.setTextColor(WHITE, BLACK);
  display.getTextBounds(text, 0, 0, &x, &y, &textWidth, &textHeight);
  display.setCursor(xPosition, yPosition - textHeight);
  display.print(text);
}

void centerCursorWithText(int16_t xOffset, int16_t yOffset, uint16_t textWidth, uint16_t textHeight) {
  display.setCursor(display.width() / 2 - textWidth / 2 + xOffset, display.height() / 2 - textHeight / 2 + yOffset);
}

String getRandomPositiveWord() {
  int index = random(sizeof(positiveWords) / sizeof(positiveWords[0])); // this is AI generated so idk if it works lol
  return positiveWords[index];
}

String getRandomNiceTryWord() {
  int index = random(sizeof(niceTryWords) / sizeof(niceTryWords[0])); // this is AI generated
  return niceTryWords[index];
}

int getRandomGame() {
  if (GAME_DEBUG_FLAG) return DEBUG_GAME_NUMBER;

  return (int) random(1, GAME_AMOUNT + 1);
}

// TIMER CODE IS AI GENERATED from chatgpt-3.5 but also edited by me to fit better so the initial code is AI

boolean setTimer(int seconds) {  
  if (isTimerRunning) return false;

  duration = ((unsigned long) seconds) * 1000; // Convert seconds to milliseconds
  return true;
}

boolean setAndStartTimer(int seconds) {
  return setTimer(seconds) && startTimer();
}

boolean startTimer() {
  if (isTimerRunning) return false;

  startTime = millis();
  isTimerRunning = true;
  
  return isTimerRunning;
}

boolean clearTimer() {
  if (!isTimerRunning) return false;

  startTime = 0;
  duration = 0;
  isTimerRunning = false;

  return true;
}

boolean checkTimerElasped() {
  boolean hasElaspedTime = millis() - startTime >= duration;
  return hasElaspedTime;
}

long remainingTimerTimeMS() {
  if (checkTimerElasped()) return 0;
  return duration - (millis() - startTime);
}

int remainingTimerTimeSeconds() {
  if (checkTimerElasped()) return 0;
  return (int) ((duration - (millis() - startTime)) / 1000);
}







